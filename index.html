<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RAWT</title>
  <link href="https://fonts.cdnfonts.com/css/akira-expanded" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      -ms-overflow-style: none;
      scrollbar-width: none;
      font-family: 'Akira Expanded', sans-serif;
    }
    body::-webkit-scrollbar { display: none; }

    canvas {
      position: fixed;
      top: 0; left: 0;
      z-index: 0;
    }

    #fadeOverlay {
      position: fixed; inset: 0;
      background: black; opacity: 0;
      transition: opacity 5s ease;
      pointer-events: none; z-index: 1;
    }

    #navBar, #bottomBar {
      position: fixed; left: 0; width: 100%; height: 60px;
      background: rgba(0,0,0,0); z-index: 1000;
      pointer-events: none;
      transition: background 0.5s ease, opacity 0.5s ease;
      display: flex; justify-content: flex-end; align-items: center; padding-right: 20px;
    }
    #navBar { top: 0; }
    #bottomBar { bottom: 0; }

    #navBar.active, #bottomBar.active {
      background: white; pointer-events: auto; mix-blend-mode: exclusion;
    }

    #bottomBar.hidden-ui { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }

    #rawtOverlay {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      font-size: 6rem; font-weight: bold; color: white;
      mix-blend-mode: exclusion; user-select: none; pointer-events: none;
      z-index: 1001;
      transition: top 0.5s ease, left 0.5s ease, transform 0.5s ease, font-size 0.5s ease;
    }
    #rawtOverlay.stuck { top: 15px; left: 30px; transform: none; font-size: 2rem; }

    #scrollContainer { height: 200vh; z-index: 1; position: relative; }

    #rawtMenu {
      position: fixed; top: 60px; left: 0;
      font-family: 'Arial', sans-serif;
      background: transparent; padding: 10px 30px;
      z-index: 1002; width: 15%; height: 100%;
      pointer-events: auto; transition: opacity 0.3s ease;
    }

    #rawtMenu ul { list-style: none; margin: 0; padding: 0; }
    #rawtMenu ul li { margin-bottom: 10px; }
    #rawtMenu ul li:last-child { margin-bottom: 0; }

    #rawtMenu ul li a {
      text-decoration: none; font-weight: bold; display: block;
      transition: color 0.3s ease; mix-blend-mode: exclusion; color: white;
    }
    #rawtMenu ul li a:hover { color: inherit; cursor: pointer; }

    .hidden { opacity: 0; pointer-events: none; user-select: none; }
    .visible { opacity: 1; pointer-events: auto; user-select: auto; }

    #hoverZone {
      position: fixed; top: 0; right: 0; width: 30px; height: 60px;
      z-index: 1100; background: transparent; pointer-events: auto;
    }

    .hidden-ui { opacity: 0; pointer-events: auto; transition: opacity 0.3s ease; }
  </style>
</head>
<body>
  <div id="fadeOverlay"></div>
  <div id="navBar"></div>
  <div id="rawtOverlay">RAWT</div>

  <div id="rawtMenu" class="hidden">
    <ul>
      <li><a href="#">NaN</a></li>
      <li><a href="#">404</a></li>
      <li><a href="#">false</a></li>
      <li><a href="#">true</a></li>
      <li><a href="#">nil</a></li>
      <li><a href="#">break</a></li>
      <li><a href="#">exit</a></li>
      <li><a href="#">fail</a></li>
      <li><a href="#">catch</a></li>
      <li><a href="#">throw</a></li>
      <li><a href="#">debug</a></li>
      <li><a href="#">stack</a></li>
      <li><a href="#">trace</a></li>
      <li><a href="#">memory</a></li>
      <li><a href="#">overrun</a></li>
      <li><a href="#">core</a></li>
      <li><a href="#">zero</a></li>
      <li><a href="#">reboot</a></li>
      <li><a href="#">sys</a></li>
      <li><a id="hideUIButton">hide-ui</a></li>
    </ul>
  </div>

  <div id="bottomBar"></div>
  <div id="scrollContainer"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", () => { window.scrollTo(0, 0); });

    const hideUIButton = document.getElementById('hideUIButton');
    const navBar = document.getElementById('navBar');
    const rawtMenu = document.getElementById('rawtMenu');
    const rawt = document.getElementById('rawtOverlay');
    const bottomBar = document.getElementById('bottomBar');

    // === Original parameters kept ===
    let SEA_SPEED = 20;
    let PLANE_SIZE = 100;
    let PLANE_SEGMENTS = 200;
    let WAVE_OCTAVES = 1;        // you can bump this now; sampler is cheap
    let WAVE_PERSISTENCE = 0.5;

    let CAMERA_X_AMPLITUDE = 0;
    let CAMERA_POS_X = 0;
    let CAMERA_BASE_HEIGHT = 10;
    let CAMERA_VERTICAL_AMPLITUDE = 2;
    let CAMERA_LOOKAT_HORIZON_AMPLITUDE = 2;
    let CAMERA_LOOKAT_VERTICAL_AMPLITUDE = 2;
    let CAMERA_POS_Z = 30;
    let CAMERA_LOOKAT_DISTANCE_BASE = 20;
    let CAMERA_LOOKAT_DISTANCE_AMPLITUDE = 10;
    let WAVE_VERTICAL_AMPLITUDE = 1.0;
    let CAMERA_SPEED_X = 0.2;
    let CAMERA_SPEED_Y = 0.3;

    let material, scene, camera, renderer, mesh, geometry;
    let seaOffsetY = Math.random() * 1000;

    // ======== PERFORMANCE: fast noise table (tileable) ========
    // Build once; we sample this instead of doing sin/floor per call.
    const NOISE_SIZE = 256;
    const NOISE_MASK = NOISE_SIZE - 1;
    let noiseTable;

    function randHash(i) {
      // Fast integer hash; no trig
      i = (i ^ 61) ^ (i >>> 16);
      i = i + (i << 3);
      i = i ^ (i >>> 4);
      i = Math.imul(i, 0x27d4eb2d);
      i = i ^ (i >>> 15);
      return i >>> 0;
    }

    function buildNoiseTable() {
      noiseTable = new Float32Array(NOISE_SIZE * NOISE_SIZE);
      // Fill with 0..1 values, then do a quick blur for smoothness
      for (let y = 0; y < NOISE_SIZE; y++) {
        for (let x = 0; x < NOISE_SIZE; x++) {
          const h = randHash(x + y * 73856093); // large prime mix
          noiseTable[y * NOISE_SIZE + x] = (h & 0xffff) / 0xffff;
        }
      }
      // 2-pass box blur (cheap smoothing)
      const tmp = new Float32Array(noiseTable.length);
      // Horizontal
      for (let y = 0; y < NOISE_SIZE; y++) {
        let acc = 0;
        for (let x = 0; x < NOISE_SIZE + 3; x++) {
          const addX = (x < NOISE_SIZE) ? x : NOISE_SIZE - 1;
          const remX = (x - 3 >= 0) ? x - 3 : 0;
          acc += noiseTable[y * NOISE_SIZE + addX];
          if (x >= 3) acc -= noiseTable[y * NOISE_SIZE + remX];
          if (x >= 2) tmp[y * NOISE_SIZE + (x - 2)] = acc / 3;
        }
      }
      // Vertical
      for (let x = 0; x < NOISE_SIZE; x++) {
        let acc = 0;
        for (let y = 0; y < NOISE_SIZE + 3; y++) {
          const addY = (y < NOISE_SIZE) ? y : NOISE_SIZE - 1;
          const remY = (y - 3 >= 0) ? y - 3 : 0;
          acc += tmp[addY * NOISE_SIZE + x];
          if (y >= 3) acc -= tmp[remY * NOISE_SIZE + x];
          if (y >= 2) noiseTable[(y - 2) * NOISE_SIZE + x] = acc / 3;
        }
      }
    }

    // Bilinear sample with wrap
    function sampleNoise(nx, ny) {
      // nx, ny are in "noise space" (floating); wrap to [0, NOISE_SIZE)
      let x = nx % NOISE_SIZE; if (x < 0) x += NOISE_SIZE;
      let y = ny % NOISE_SIZE; if (y < 0) y += NOISE_SIZE;
      const x0 = x | 0, y0 = y | 0;
      const x1 = (x0 + 1) & NOISE_MASK;
      const y1 = (y0 + 1) & NOISE_MASK;
      const fx = x - x0, fy = y - y0;

      const i00 = noiseTable[y0 * NOISE_SIZE + x0];
      const i10 = noiseTable[y0 * NOISE_SIZE + x1];
      const i01 = noiseTable[y1 * NOISE_SIZE + x0];
      const i11 = noiseTable[y1 * NOISE_SIZE + x1];

      const ix0 = i00 + (i10 - i00) * fx;
      const ix1 = i01 + (i11 - i01) * fx;
      return ix0 + (ix1 - ix0) * fy;
    }

    // Your fractalNoise API, but now sampling the table (cheap!)
    function fractalNoise(x, y, octaves = WAVE_OCTAVES, persistence = WAVE_PERSISTENCE) {
      let total = 0, frequency = 1, amplitude = 1, maxValue = 0;
      for (let i = 0; i < octaves; i++) {
        // Scale into table space; 32 is arbitrary "zoom" for pleasing detail
        total += sampleNoise(x * frequency * 32, y * frequency * 32) * amplitude;
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= 2;
      }
      return total / (maxValue || 1);
    }

    function getRandomGrey() {
      const shade = Math.floor(Math.random() * 205);
      return (shade << 16) | (shade << 8) | shade;
    }

    function randomBetween(min, max) { return Math.random() * (max - min) + min; }
    function getRandomColor() { return Math.floor(Math.random() * 0xffffff); }

    // Cache for per-vertex XY to avoid getX/getY every frame
    let vertexXY = null;
    let posAttr = null;
    let posArray = null;
    let vertexCount = 0;

    function createSeaMesh() {
      if (mesh) {
        scene.remove(mesh);
        geometry.dispose();
        mesh.material.dispose();
      }
      geometry = new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, PLANE_SEGMENTS, PLANE_SEGMENTS);
      mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI / 2;
      scene.add(mesh);

      // Cache references
      posAttr = geometry.attributes.position;
      posArray = posAttr.array;
      vertexCount = posAttr.count;

      // Build XY cache once (local plane coords)
      vertexXY = new Float32Array(vertexCount * 2);
      for (let i = 0, j = 0; i < vertexCount; i++, j += 3) {
        vertexXY[i * 2]     = posArray[j + 0]; // x
        vertexXY[i * 2 + 1] = posArray[j + 1]; // y
      }
    }

    function randomise() {
      WAVE_VERTICAL_AMPLITUDE = randomBetween(0.2, 1.5);
      CAMERA_LOOKAT_DISTANCE_AMPLITUDE = randomBetween(0, 100);
      CAMERA_LOOKAT_VERTICAL_AMPLITUDE = randomBetween(0, 20);
      CAMERA_LOOKAT_HORIZON_AMPLITUDE = randomBetween(0, 20);
      CAMERA_VERTICAL_AMPLITUDE = randomBetween(0, 20);
      CAMERA_BASE_HEIGHT = randomBetween(10, 50);
      CAMERA_X_AMPLITUDE = randomBetween(0, 50);
      SEA_SPEED = Math.random() > 0.5 ? 0 : 20;
      if (material) material.color.setHex(getRandomColor());
    }

    function init() {
      if (renderer) renderer.domElement.remove();

      // Build noise table once per init
      buildNoiseTable();

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(CAMERA_POS_X, CAMERA_BASE_HEIGHT, CAMERA_POS_Z);

      // Keep antialias true like yours; we’ll still be fast due to CPU cuts.
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(getRandomGrey(), 1);
      // Slightly limit pixel ratio for headroom; comment this line if you want exact original.
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 100, 100).normalize();
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      material = material || new THREE.MeshStandardMaterial({
        color: 0xFFFFFF, wireframe: true, roughness: 0.7, metalness: 0.2, transparent: true, opacity: 1,
      });

      randomise();
      createSeaMesh();
      window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const time = clock.elapsedTime;

      seaOffsetY += SEA_SPEED * delta;
      if (seaOffsetY > 1000) seaOffsetY -= 1000;

      camera.position.x = CAMERA_POS_X + Math.sin(time * CAMERA_SPEED_X) * CAMERA_X_AMPLITUDE;
      camera.position.y = CAMERA_BASE_HEIGHT + Math.sin(time * CAMERA_SPEED_Y) * CAMERA_VERTICAL_AMPLITUDE;
      camera.position.z = CAMERA_POS_Z;

      const lookAtDistance = CAMERA_LOOKAT_DISTANCE_BASE + Math.sin(time * 0.02) * CAMERA_LOOKAT_DISTANCE_AMPLITUDE;
      const horizonOffset = Math.sin(time * 0.2) * CAMERA_LOOKAT_HORIZON_AMPLITUDE;
      const verticalOffset = Math.sin(time * 0.1) * CAMERA_LOOKAT_VERTICAL_AMPLITUDE;

      camera.lookAt(new THREE.Vector3(
        CAMERA_POS_X + verticalOffset,
        horizonOffset,
        CAMERA_POS_Z - lookAtDistance
      ));

      // === HOT PATH: optimized vertex update ===
      // Avoid getX/getY and setZ; write directly into the Float32Array.
      // posArray layout: [x,y,z, x,y,z, ...]
      for (let i = 0, j = 2, k = 0; i < vertexCount; i++, j += 3, k += 2) {
        const x = vertexXY[k];
        const y = vertexXY[k + 1];
        const waveY = y - seaOffsetY;

        // Keep your 3-layer combo; now sampled from the table (fast)
        const n1 = fractalNoise(x * 0.1 + time * 0.05, waveY * 0.1 + time * 0.03) * 4;
        const n2 = fractalNoise(x * 0.4 - time * 0.07, waveY * 0.4 + time * 0.02, 3, 0.6) * 3;
        const n3 = fractalNoise(x * 1.5 + time * 0.12, waveY * 1.5 - time * 0.08, 2, 0.7) * 2;

        posArray[j] = WAVE_VERTICAL_AMPLITUDE * (n1 + n2 + n3);
      }
      posAttr.needsUpdate = true;

      renderer.render(scene, camera);
    }

    function fadeOutAndReset() {
      const fadeOverlay = document.getElementById('fadeOverlay');
      fadeOverlay.style.opacity = '1';
      setTimeout(() => {
        seaOffsetY = Math.random() * 1000;
        init();
        setTimeout(() => {
          fadeOverlay.style.opacity = '0';
          setTimeout(fadeOutAndReset, 15000);
        }, 100);
      }, 5000);
    }

    init();
    animate();
    setTimeout(fadeOutAndReset, 15000);

    // ======= UI logic (merged to avoid double scroll work) =======
    const menuLinks = document.querySelectorAll('#rawtMenu ul li a');

    // Link hover color follows material color
    function currentColorHex() { return '#' + material.color.getHexString(); }

    menuLinks.forEach(link => {
      const originalColor = window.getComputedStyle(link).color;
      link.addEventListener('mouseenter', () => { link.style.color = currentColorHex(); });
      link.addEventListener('mouseleave', () => { link.style.color = originalColor; });
    });

    hideUIButton.addEventListener('mouseenter', () => { hideUIButton.style.color = currentColorHex(); });
    hideUIButton.addEventListener('mouseleave', () => { hideUIButton.style.color = 'white'; });

    let uiHidden = false;
    function updateHideUIButtonVisibility() {
      if (navBar.classList.contains('active') && !uiHidden) {
        hideUIButton.classList.add('visible-ui');
      } else {
        hideUIButton.classList.remove('visible-ui');
      }
    }

    hideUIButton.addEventListener('click', () => {
      uiHidden = true;
      navBar.classList.add('hidden-ui');
      rawtMenu.classList.add('hidden-ui');
      bottomBar.classList.add('hidden-ui');
      updateHideUIButtonVisibility();
    });

    function showUI() {
      uiHidden = false;
      navBar.classList.remove('hidden-ui');
      rawtMenu.classList.remove('hidden-ui');
      bottomBar.classList.remove('hidden-ui');
      updateHideUIButtonVisibility();
    }

    // Single scroll handler (the original had two)
    window.addEventListener('scroll', () => {
      const isStuck = window.scrollY > window.innerHeight / 2;

      rawt.classList.toggle('stuck', isStuck);
      navBar.classList.toggle('active', isStuck);
      bottomBar.classList.toggle('active', isStuck);

      if (isStuck) {
        rawtMenu.classList.add('visible'); rawtMenu.classList.remove('hidden');
      } else {
        rawtMenu.classList.add('hidden'); rawtMenu.classList.remove('visible');
      }

      updateHideUIButtonVisibility();
    }, { passive: true });

    // Show UI on hover when hidden
    rawtMenu.addEventListener('mouseenter', () => { if (uiHidden) showUI(); });
    navBar.addEventListener('mouseenter', () => { if (uiHidden) showUI(); });

    updateHideUIButtonVisibility();
  </script>
</body>
</html>
